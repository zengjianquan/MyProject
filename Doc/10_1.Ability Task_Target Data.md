## 简介

通过前几篇的学习，我们制作了一个投掷物的 `GA`，并且使用了两个 `GAS` 中已经实现的 `Ability Task`。

在本篇中，我们将修复投掷物的问题，<u>让其能够往正确的方向去发射投掷物</u>。在这我们使用 `Ability Task` 来实现这一操作。

## 自定义 Ability Task

为了修复上述的问题，我们需要获取鼠标点击的位置，在这里我们通过自定义的 `Ability Task` 来实现：

![1716537466824](image/1716537466824.png)

和之前使用的 `Ability Task` 一样，我们需要定义静态的创建方法，并且实现 `Activate` 方法，然后定义一个动态的多播委托，这样在蓝图中调用静态创建方法时：

![1716537535502](image/1716537535502.png)

便会如上图所示。

> `Valid Data` 是一个委托成员，`Data` 是其参数，即在蓝图中进行绑定。

然后我们实现这些方法：

![1716537648896](image/1716537648896.png)

如上图，这里获取 `PlayerController` 的方法是通过 `Ability` 成员获取 `Actor Info`，然后通过其内置获得光标点击位置的方法，获得位置后将委托成员进行广播。

`Actor Info` 是一个有很多信息的数据集合（`AvatarActor`）：

![1716537731415](image/1716537731415.png)

> 只展示一部分。

然后我们修改一下 `GA` 蓝图：

![1716537891470](image/1716537891470.png)

获取点击位置后直接画一个球：

![1716537924056](image/1716537924056.png)

可以看到运行结果看上去还挺正确的，但是当我们 **进入多人模式** 后：

![1716538194990](image/1716538194990.png)

如上图所示，红色框中为客户端，正确运行，而在绿色框中的服务端中，应该出现的白色球却不见了。

究其原因，其实是在 `Activate` 中，`Client` 的 `GetHitResultUnderCursor` 能够获得鼠标点击位置：

![1716539206978](image/1716539206978.png)

但是在 `Server` 中，是获取不了的：

![1716539251748](image/1716539251748.png)

如上图，这是因为在 `Server` 中，虽然有客户端的 `PlayerController`，但却没有客户端的 `LocalPlayer`，因此是不能够获得 `HitResult` 的。

因此委托就没有执行，那么就不会 `DrawDebugSphere` 了。。。

## Target Data

出现上述的情况，究其原因，一个 `Instanced GA` 是一个可以网络复制的对象（也可以参考 [9_2.Gameplay Ability_Settings](./9_2.Gameplay Ability_Settings.md) 中的 <u>注意事项</u>）：

![1716540223264](image/1716540223264.png)

**<u>那么在 `Activate` 时，`Ability Task` 是在客户端中进行调用的</u>**。所以才会出现在 `Server` 中找不到 `LocalPlayer` 的情况。

为了将客户端产生的数据发送到服务端，我们一般会想到：

![1716541829926](image/1716541829926.png)

如上图，在客户端 `Activate` 后，计算好数据之后发送给服务端。但由于复杂的网络问题，客户端通知服务端执行 `Activate` 的时间 和 `RPC` 传输数据的时间不好控制。

所以 `GAS` 提供了一套解决方案，即 `Target Data System`：

![1716542080194](image/1716542080194.png)

如上图，在客户端中，通过 `ServerSetReplicatedTargetData` 将客户端的数据发送到服务端，服务端通过绑定的 `Delegate` 来获得这个数据，并且在服务端中维护一套 `Spec -> Data` 的关联表。

那么我们的整体流程将进行改变：

![1716542191292](image/1716542191292.png)

如上图，当客户端 `Activate` 时，我们可以调用上述的函数，将数据发送到服务端；服务端则需要绑定对应的接收数据的委托。

> 注意，执行 `RPC` 的时刻可能会早于绑定的时刻，因此在服务端中执行 `CallReplicatedTargetDataDelegateIfSet`，即绑定了才执行，相当于上一层保险。

